---
 draft: false
 outputs: sig-format
 title: Nixos and K3S
 date: 2026-02-09
 ---
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

Hey, been a while… as usual. This is very much thrown together as a post, but I wanted to document the completion of two pretty big projects. I have finally deployed a K3S cluster in my homelab, and I have successfully moved from Arch to NixOS.

> ⚠️ **Warning:** This is not a tutorial or guide. Please run the commands in this post at your own risk.

- ---

## I use Nix BTW

I finally moved from using Arch Linux as my OS of choice to running NixOS. It seemed like a natural next step in me becoming an insufferable no-lifer. I won’t pit Kubernetes and NixOS against each other for which one I have intended to switch to for longer; both have held court in the tattered throne-room that is my prefrontal cortex for so long they are better treated as jesters rather than legitimate guests.

I moved over to NixOS around four months ago because my Arch install finally keeled over and died. I could either prolong my pain using it or just install Nix like I had been saying I wanted to do for at least two years. I bit the bullet, creating an incredibly misguided abomination of a flake. Things were good… then I proceeded to break the flake after three days and used a Nix build two generations old for a third of a year.

Why I eventually fixed this, I do not know. It may be as simple as one day at work a coworker was annoying me and I decided to plan out a new Git repo called **Atlantis**, which threw fresh goals onto the smithery inside my brain.

Atlantis was born, so named after the club frequented by solos in *Night City* in *Cyberpunk 2020*. Atlantis was going to be different — elegant, stable. Atlantis sat for two weeks with no work beyond a basic skeleton. Then just as the coals were about to cough their last plume, the NixOS jester spilt his flagon atop them, and the ethanol lit a three‑day sprint of building, tweaking, committing, and refactoring.

I now have a functioning, Git-backed, fully declarative operating system at my fingertips. It is rare that I leave a project feeling fulfilled, but this was one of those times. I am genuinely happy with what I achieved.

- ---

### GPG Unification

The coolest thing I did in all of this was unify my GPG and SSH setup.

This is something I had wanted to do for a long time, but doing it on Arch meant learning everything, implementing it, and then inevitably repeating the process after the next reinstall. With NixOS, I only had to set it up once.

When I initially set up my GPG keys, I made mistakes:

1. Uploading my root key to Keybase (your private key should never touch the internet — I knew this and did it anyway).
2. Not using subkeys.
3. Not uploading my key to a keyserver.

Over the course of a wet February evening, I installed TailsOS onto a USB stick, booted into it, and generated the following:

```text
pub   ed25519/0xB254FBF3F060B796 2026-02-05 [SC] [expires: 2031-02-04]
uid   [ultimate] Eddie Brinton-Quinn <eddie@b-quinn.com>
sub   ed25519/0x72E0089944E7C367 2026-02-05 [S]
sub   cv25519/0x51FC7D57ABD18A33 2026-02-05 [E]
sub   ed25519/0x4AAC046885DFBC2B 2026-02-05 [A]
sub   ed25519/0xBFEEDA71CC19B0C6 2026-02-05 [A]
```

That is a primary key with four subkeys:

* One for signing
* One for encryption
* Two for authentication (one per device)

Six hours later, I had a `+85 -7` merge request. The file doing most of the work looked like this:

```nix
{ config, pkgs, lib, ... }:

{
  programs.gpg = {
    enable = true;
    settings = {
      keyserver = "hkps://keys.openpgp.org";
    };
  };

  services.gpg-agent = {
    enable = true;
    enableSshSupport = true;
    enableZshIntegration = true;
    pinentry.package = pkgs.pinentry-gtk2;
    defaultCacheTtl = 3600;
    maxCacheTtl = 86400;
  };

  programs.zsh.initContent = ''
    export SSH_AUTH_SOCK="$(${pkgs.gnupg}/bin/gpgconf --list-dirs agent-ssh-socket)"
  '';

  programs.ssh = {
    enable = true;
    enableDefaultConfig = false;

    matchBlocks."all" = {
      host = "*";
      identityAgent = "/run/user/1000/gnupg/S.gpg-agent.ssh";
    };
  };
}
```

I am proud of this. Genuinely.

- ---

## I use K3S BTW

The actual reason I started writing this: I deployed a K3S cluster.

Why? Partly curiosity. Partly ego. Partly because I enjoy pushing my understanding of GitOps, virtualization, Docker, and infrastructure to uncomfortable places.

I do not need a HA cluster. But I wanted one.

My main blocker historically wasn’t Kubernetes — it was repetition. I refuse to manually build and rebuild seven VMs every time I change something. That feels pointless.

So I needed Infrastructure as Code.

- ---

## I use OpenTofu BTW

OpenTofu and Terraform are both IaC tools. Terraform moved to the BSL license; OpenTofu forked under MPL-2.0.

That’s the main difference.

With some research, a few LLM prompts, YouTube, and a case of Hazy Jane, I ended up with the following Proxmox configuration:

```tf
resource "proxmox_vm_qemu" "k3s" {
  for_each = local.nodes

  name        = "${var.name_prefix}-${each.key}"
  target_node = var.target_node
  clone       = var.clone_template
  vmid        = each.value.vmid
  full_clone  = true
  tags        = "k3s-cluster"

  agent       = 1
  skip_ipv6   = true

  cpu {
    cores = each.value.cpu
    type  = "host"
  }

  memory  = each.value.mem
  os_type = "cloud-init"

  network {
    id      = 0
    model   = "virtio"
    bridge  = var.bridge
    macaddr = each.value.macaddr
  }

  ciuser    = var.ci_user
  sshkeys   = var.ssh_public_key
  ipconfig0 = var.ipconfig0
}
```

Terraform builds the VMs. Ansible provisions them. k3sup bootstraps the cluster.

- ---

## I use k3sup BTW

k3sup installs and manages k3s over SSH.

Bootstrap command:

```bash
k3sup install \
  --ip 10.0.6.11 \
  --tls-san 10.0.6.10 \
  --cluster \
  --user k3s-agent \
  --local-path ~/.kube/config \
  --context k3s-ha \
  --k3s-extra-args "disable servicelb --node-ip 10.0.6.11"
```

kube-vip provides a virtual IP (10.0.6.10) for HA API access.

After joining the remaining nodes, I ended up with:

```bash
kubectl get nodes -o wide
```

Seven nodes. Three control-plane. Four workers. HA etcd. Stable.

And now I have a cluster I need to actually use.

Next step: GitOps.

- ---

## Aftercare

Would I recommend this?

Absolutely not.

You will fall into one of three camps:

* **“Wow, that’s awesome.”** You’re already planning to do this.
* **“Should I do this?”** If this is you — probably not. You don’t need a declarative OS or HA cluster unless it excites you.
* **“This sounds pointless.”** That’s fine too.

If you are not filled with excitement at the thought of building this, save your energy for something that does.

It works. I built it. Now I get to see what I can do with it.

See you in nine months when I post again.
-----BEGIN PGP SIGNATURE-----

iHUEARYKAB0WIQT2PKczXr7LvRlhryhy4AiZROfDZwUCaY24NQAKCRBy4AiZROfD
Z1A6AP4/jXTVTxiCxHszAAn2vPSfzHjkLbMVDjtGwgxVB7RpHwEAkndoilsDpCjF
SFU+Te387KGgveglN1Bbs78aynaoJw4=
=sg1f
-----END PGP SIGNATURE-----
